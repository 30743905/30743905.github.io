<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Disruptor之概览]]></title>
    <url>%2F2018%2F01%2F26%2FDisruptor%E4%B9%8B%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[Diruptor概述“多核危机”驱动了并发编程的复兴，然后并发编程和一般的系统相比，复杂性有个很大梯度的上升。多线程开发很大困难在于：多个线程间存在依赖关系时，如何进行协调。依赖一方面是执行顺序的依赖，如某个线程执行需要依赖其他线程执行或其它线程的某些阶段执行结果，Java为我们提供的解决方案是：wait/notify、lock/condition、join、yield、Semaphore、CountDownLatch、CyclicBarrier以及JDK7新增的一个Phaser等；数据依赖主要是多个线程对同一资源并发修改导致的数据状态不一致问题，Java中主要依靠Lock和CAS两种方案，也就是我们熟知的悲观锁、乐观锁。 然而，当你在并发编程方面慢慢有些经验并开始在项目中使用时，你会发现仅仅依赖JDK提供的上面所说开发工具类是远远不够的， JDK提供的工具类都只能解决一个个功能“点”的问题。并发编程复杂性一个体现就是：多个顺序执行流在多核CPU中同时并行执行与我们已经习惯的单个数据顺序流执行的方式产生了很大的冲突。 好比：现在你开车从A地到B地去，传统的开发模式就像从A地到B地之间只存在一条公路，你只需要延着这个公路一直开下去就可以达到B地；假如经过多年发展，现在A地到B地横起有10条公路，纵起有10条公路，它们之间相互交叉形成错综复杂的公路网，你再开车从A地到B地就会存在太多的选择，可能从东南西北任何方向出发最终都能到达B地。这就体现了并发编程和传统编程复杂性的对比：传统编程由于只存在一个顺序执行流，可以很好的预判程序的执行流程；而并发编程存在太多的顺序执行流导致很难准确的预判出它们真正的执行流程，一旦出现问题也很难排查，就好比上面的例子第二种情况，你很难预判你开车的真正路线，而且可能存在每次路线都不一样情况。 我认为一个并发编程项目好坏其中一个关键核心就是：项目的整体结构是否清晰。很简单的一个例子，调用notify()方法唤醒挂起在指定对象上的休眠线程，如果没有一个清晰简单的架构设计，可能会导致在该对象上进行休眠的对象散落到系统中各处代码上，很难把控具体唤醒的是哪个线程从而与你的业务逻辑发生偏差导致bug的出现。当然，项目结构清晰在传统编程中也是非常看重的，只有结构清晰的架构才会让人易于理解，同时和他人沟通探讨时方便描述，但是在并发编程中这点尤为重要，因为并发编程的复杂性更高，没有一个清晰的结构设计，你可能经过大量测试修改暂时做出了一个看似没有bug的项目，但是后期需求变更或者是其他人来维护这个项目时，很难下手导致后期会引入大量的bug，而且不利于项目功能的扩展。 常用的并发编程使用的模型有并行模型、流水线模型、生产者/消费者模型、Actor模型等，采用模型设计一方面是因为这些模型都是大牛们经过长时间实际生产经验的积累总结出的并发编程方面一些好的解决方案；另一方面，采用模型设计可以解决相关人员之间沟通信息不对等问题，降低沟通学习成本。 并行模型是JDK8中Stream所采用的实现并发编程的方式，并行模型非常简单，就是为每个任务分配一个线程直到该任务执行结束，示意图如下： 并行模型太过简单导致对任务的精细化控制不足，一个任务可能会被分解为多个阶段，而每个阶段的子任务特性可能差别很大，这时并行模型就无能为力了。并行模型只适合于CPU密集型且任务中不含IO阻塞等情况的任务。这时，就演进出流水线模型，示意图如下： 流水线模型在实际的并发编程中使用比较常见，我们所说的Pipeline设计模型、Netty框架等都是这一思想的体现。 生产者/消费者模型在并发编程中也是使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。 Actor模型其典型代表就是Akka，基于Akka可以轻松实现一个分布式异步数据处理集群系统，非常强大，后期我们有机会可以再深入讨论下Akka。 好了，说了这么多，终于要开始正题：Disruptor，官方宣传基于该框架构建的系统单线程可以支撑每秒处理600万订单，此框架真乃惊为天人。Disruptor在生产者/消费者模型上获得尽量高的吞吐量和尽量低的延迟，其目标就是在性能优化方面做到极致。国内国外都存在大量的知名项目在广泛使用，比如我们所熟知的strom底层就依赖Disruptor的实现，其在并发、缓存区、生产者/消费者模型、事务处理等方面都存在一些性能优秀的方案，因此是非常值得深入研究的。 生产者/消费者模型生产者/消费者模型在编程中使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。生产者/消费者和我们所熟悉的设计模式中的观察者模型很相似，生产者类似于被观察者，消费者类似于观察者，被观察者的任何变动都以事件的方式通知到观察者；同理，生产者生产的数据都要传递给消费者最终都要被消费者处理。 一般项目开发中，我们可以使用JDK提供的阻塞队列BlockingQueue很简单的实现一个生产者/消费者模型，其中生产者线程负责提交需求，消费者线程负责处理任务，二者之间通过共享内存缓冲区进行通信。 BlockingQueue实现类主要有两个：ArrayBlockingQueue和LinkedBlockingQueue，底层实现一个是基于数组的，一个是基于链表的，这种实现方式的差异导致了它们使用场景的不一样。在生产者/消费者模型中的缓存设计上肯定优先使用ArrayBlockingQueue，但是查看ArrayBlockingQueue底层源码会发现，读写操作通过重入锁实现同步，而且读写操作使用的是同一把锁，并没有实现读写锁分离；另外，锁本身的成本还是比较高的，锁容易导致线程上下文频繁的发生切换，了解CPU核存储硬件架构的可能会知道，每核CPU都会存在一个独享的高速缓存L1，假如线程切换到其它CPU上执行会导致之前CPU高速缓存L1中的数据不能再被使用，降低了高速缓存使用效率。因此，在高并发场景下，性能不是很优越。 12345678910111213141516171819202122232425//向Queue中写入数据public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly();//可中断方式获取锁，实现同步 try &#123; while (count == items.length) notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125;&#125;//从Queue中取出数据public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly();//可中断方式获取锁，实现同步 try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; Disruptor消息生产模型 Producer生产出一个消息事件Event，需要放入到RingBuffer中，流程大致如下： ​ 1、首先调用Sequencer.next()方法，获取RingBuffer上可用的序号用于将新生成的消息事件放入； ​ 2、Sequencer首先对nextValue+1代表当前需要申请的RingBuffer序号(nextValue标记了之前已经申请过的序号,nextValue+1就是下一个可申请的序号)，但是nextValue+1指向的RingBuffer槽位存放的消息可能并没有被消费，如果直接返回这个序号给生产者，就会导致生产一方将该槽位的消息事件重新填充覆盖导致之前数据丢失，这里就需要一个判断：判断申请的RingBuffer序号代表的槽位之前的消息事件是否已被消费，判断逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public long next(int n) &#123; if (n &lt; 1) //n表示此次生产者期望获取多少个序号，通常是1 &#123; throw new IllegalArgumentException("n must be &gt; 0"); &#125; long nextValue = this.nextValue; //这里n一般是1，代表申请1个可用槽位，nextValue+n就代表了期望申请的可用槽位序号 long nextSequence = nextValue + n; //减掉RingBuffer的bufferSize值，用于判断是否出现‘绕圈覆盖’ long wrapPoint = nextSequence - bufferSize; //cachedValue缓存之前获取的最慢消费者消费到的槽位序号 long cachedGatingSequence = this.cachedValue; //如果申请槽位序号-bufferSize比最慢消费者序号还大，代表生产者绕了一圈后又追赶上了消费者，这时候就不能继续生产了，否则把消费者还没消费的消息事件覆盖 if (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123; /** cursor代表当前已经生产完成的序号，了解多线程可见性可能会知道： 1、CPU和内存间速度不匹配，硬件架构上一般会在内存和CPU间还会存在L1、L2、L3三级缓存 2、特别是L1高速缓存是CPU间相互独立不能共享的，线程操作可以看着基于L1缓存进行操作，就会导致线程间修改不会立即被其它线程感知，只有L1缓存的修改写入到主存然后其它线程将主存修改刷新到自己的L1缓存，这时线程1的修改才会被其它线程感知到 3、线程修改对其它线程不能立即可见特别是在高并发下可能会带来些问题，JAVA中使用volatile可以解决可见性问题 4、这里就是采用UNSAFE.putLongVolatile()插入一个StoreLoad内存屏障，具体可见JMM模型，主要保证cursor的真实值对所有的消费线程可见，避免不可见下消费线程无法消费问题 */ cursor.setVolatile(nextValue); long minSequence; //Util.getMinimumSequence(gatingSequences, nextValue)获取当前时刻所有消费线程中，消费最慢的序号 //上面说过cachedValue是缓存的消费者最慢的序号 //这样做目的：每次都去获取真实的最慢消费线程序号比较浪费资源，而是获取一批可用序号后，生产者只有使用完后，才继续获取当前最慢消费线程最小序号，重新获取最新资源 while (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123; //如果获取最新最慢消费线程最小序号后，依然没有可用资源，做两件事： // 1、唤醒waitStrategy上所有休眠线程，这里即是消费线程(避免因消费线程休眠而无法消费消息事件导致生产线程一直获取不到资源情况) // 2、自旋休眠1纳秒 //可以看到，next()方法是一个阻塞接口，如果一直获取不到可用资源，就会一直阻塞在这里 waitStrategy.signalAllWhenBlocking(); LockSupport.parkNanos(1L); &#125; //有可用资源时，将当前最慢消费线程序号缓存到cachedValue中，下次再申请时就可不必再进入if块中获取真实的最慢消费线程序号，只有这次获取到的被生产者使用完才会继续进入if块 this.cachedValue = minSequence; &#125; //申请成功，将nextValue重新设置，下次再申请时继续在该值基础上申请 this.nextValue = nextSequence; //返回申请到RingBuffer序号 return nextSequence; &#125; ​ 3、申请到可用序号后，提取RingBuffer中该序号中的Event，并重置Event状态为当前最新事件状态 ​ 4、重置完成后，调用Sequencer.publish()提交序号，提交序号主要就是修改cursor值，cursor标记已经生产完成序号，这样消费线程就可以来消费事件了 12345678@Overridepublic void publish(long sequence)&#123; //修改cursor序号，消费者就可以进行消费 cursor.set(sequence); //唤醒消费线程，比如消费线程消息到无可用消息时可能会进入休眠状态，当放入新消息就需要唤醒休眠的消费线程 waitStrategy.signalAllWhenBlocking();&#125; 总结：消息事件生产主要包含三个步骤： ​ 1、申请序号：表示从RingBuffer上获取可用的资源 ​ 2、填充事件：表示获取到RingBuffer上可用资源后，将新事件放入到该资源对应的槽位上 ​ 3、提交序号：表示第二部新事件放入到RingBuffer槽位全部完成，提交序号可供消费线程开始消费 Disruptor消息处理模型 消息处理端需要从RingBuffer中提取可用的消息事件，并注入到用户的业务逻辑中进行处理，流程大致如下： ​ 1、消费端核心类是EventProcessor，它实现了Runnable接口，Disruptor在启动的时候会将所有注册上来的EventProcessor提交到线程池中执行，因此，一个EventProcessor可以看着一个独立的线程流用于处理RingBuffer上的数据 ​ 2、EventProcessor通过调用SequenceBarrier.waitFor()方法获取可用消息事件的序号，其实SequenceBarrier内部还是调用WaitStrategy.waitFor()方法，WaitStrategy等待策略主要封装如果获取消息时没有可用消息时如何处理的逻辑信息，是自旋、休眠、直接返回等，不同场景需要使用不同策略才能实现最佳的性能 12345678910111213141516171819202122232425262728293031323334ProcessingSequenceBarrier： WaitStrategy waitStrategy; Sequence dependentSequence; boolean alerted = false; Sequence cursorSequence;//可供消费消息的sequence Sequencer sequencer;ProcessingSequenceBarrier中核心方法只有一个：waitFor(long sequence)，传入希望消费得到起始序号，返回值代表可用于消费处理的序号，一般返回可用序号&gt;=sequence，但也不一定，具体看WaitStrategy实现/** * 总结： * 1、sequence：EventProcessor传入的需要进行消费的起始sequence * 2、这里并不保证返回值availableSequence一定等于given sequence，他们的大小关系取决于采用的WaitStrategy * a.YieldingWaitStrategy在自旋100次尝试后，会直接返回dependentSequence的最小seq，这时并不保证返回值&gt;=given sequence * b.BlockingWaitStrategy则会阻塞等待given sequence可用为止，可用并不是说availableSequence == given sequence，而应当是指 &gt;= * c.SleepingWaitStrategy:首选会自旋100次，然后执行100次Thread.yield()，还是不行则LockSupport.parkNanos(1L)直到availableSequence &gt;= given sequence */ @Override public long waitFor(final long sequence) throws AlertException, InterruptedException, TimeoutException &#123; checkAlert(); //调用WaitStrategy获取RingBuffer上可用消息序号，无可消费消息是该接口可能会阻塞，具体逻辑由WaitStrategy实现 long availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this); if (availableSequence &lt; sequence) &#123; return availableSequence; &#125; //获取消费者可以消费的最大的可用序号，支持批处理效应，提升处理效率。 //当availableSequence &gt; sequence时，需要遍历 sequence --&gt; availableSequence，找到最前一个准备就绪，可以被消费的event对应的seq。 //最小值为：sequence-1 return sequencer.getHighestPublishedSequence(sequence, availableSequence); &#125; ​ 3、通过waitFor()返回的是一批可用消息的序号，比如申请消费7好槽位，waitFor()返回的可能是8表示从6到8这一批数据都已生产完毕可以进行消费 ​ 4、EventProcessor按照顺序从RingBuffer中取出消息事件，然后调用EventHandler.onEvent()触发用户的业务逻辑进行消息处理 1234567891011121314151617181920212223while (true) &#123; try &#123; //读取可消费消息序号 final long availableSequence = sequenceBarrier.waitFor(nextSequence); if (batchStartAware != null) &#123; batchStartAware.onBatchStart(availableSequence - nextSequence + 1); &#125; while (nextSequence &lt;= availableSequence) &#123; //循环提取所有可供消费的消息事件 event = dataProvider.get(nextSequence); //将提取的消息事件注入到封装用户业务逻辑的Handler中 eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence); nextSequence++; &#125; sequence.set(availableSequence); &#125; &#125;&#125; ​ 5、当这批次的消息处理完成后，继续重复上面操作调用waitFor()继续获取可用的消息序号，周而复始]]></content>
      <categories>
        <category>Disruptor</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>计算模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时区总结]]></title>
    <url>%2F2018%2F01%2F25%2F%E6%97%B6%E5%8C%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近工作上涉及到些时区概念，在同事交流过程中顺便总结了下。 时区下面用如下系统结构介绍下时区概念： 1、现在前端WEB需要获取到当前时间:new Date() ，new Date()创建时间代表当前时刻，是不涉及到任何时区问题的，Date类型的API中也没有任何和时区进行关联的方法，Date可以代表对时间戳long的一个封装，表示一个瞬时时刻，Date.getTime()方法就可以获取到当前封装的时间戳值，同理也可以通过new Date(时间戳)来创建一个时间，比如当前时间戳：1514966524591L 2、现在要把这个获取到的new Date()传递到服务A中，假如使用常用到的REST接口进行传递，我们知道REST是通过Json字符串传递参数的，这就涉及到Date到字符串转换的问题了，要用到SimpleDateFormat时间格式化类： 1234SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");System.out.println(dateFormat.format(date));输出如下：2018-01-03 16:02:04.591 由于时间格式化时没有指定时区，默认采用当前系统时区，所以这个输出就代表：北京时间(东八区)2018-01-03 16:02:04.591。当然现在框架都是集成了Json转换工具类，你不需要像我这里自己创建SimpleDateFormat然后指定时区，但原理都是一样的，一般框架将Date转成Json对象都是会提供设置时区的接口的。 如果和服务A约定使用UTF零时区而不是使用本地时区呢，因为使用本地时区存可能会存在问题，假如WEB服务部署到东九区而不是东八区，这样使用SimpleDateFormat解析new Date()使用的是东九区时区，服务A收到了可能依然会认为是东八区，这样服务A解析传递过来的时间字符串就会存在问题。WEB服务和服务A就可以约定传递使用UTF时区，保证就不会出现问题，但是WEB在将Date转成String的时候需要指定UTF时区，不能再使用默认的系统本地时区了，如下： 12345SimpleDateFormat dateFormat2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");dateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));//指定为UTF时区System.out.println(dateFormat.format(date));输出如下：2018-01-03 08:02:04.591 发现比之前的2018-01-03 16:02:04.591少了8个小时，这就体现了同一个时间，在不同时区代表的具体时间，即几月几日，几点几分是不一样的，但是东八区的2018-01-03 16:02:04.591和UTF时区的2018-01-03 08:02:04.591代表的是同一个时间，即同一时刻。 3、服务A接收到2018-01-03 16:02:04.591这个代表时间的字符串，需要将其转成成Date类型，它就需要知道这个时间字符串到底代表那个时区的，当然如果服务A本身就是运行在东八区就不需要指定时区(默认和系统时区保持一致)，否则解析的时候就需要指定具体的时区： 1234567String timeStr = "2018-01-03 16:02:04.591";SimpleDateFormat dateFormat2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");dateFormat2.setTimeZone(TimeZone.getTimeZone("GMT+8:00"));Date date2 = dateFormat2.parse(timeStr);System.out.println(date2.getTime());输出：1514966524591(和WEB传入的Date的时间戳一致，即传递过程正常) 如果WEB传递过来的是UTF时区时间：2018-01-03 08:02:04.591，服务A解析如下：1234567String timeStr = "2018-01-03 08:02:04.591";SimpleDateFormat dateFormat3 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");dateFormat3.setTimeZone(TimeZone.getTimeZone("GMT"));//指定用UTF时区解析时间Date date3 = dateFormat3.parse(timeStr);System.out.println(date3.getTime());输出：1514966524591(和WEB传入的Date的时间戳一致，即传递过程正常) 总结：如果系统间时区不一致，或者约定传递时间用UTF时间格式，就要保证两个方面： 1、传递方在将Date解析成字符串时指定时区为UTF 2、接收方在接收到时间字符串进行解析成Date类型时，也需要指定时区为UTF 3、如果不指定都会采用系统默认时区，可能就会存在问题 4、服务A正常解析出WEB传递过来的时间后，写入到数据库表中的一个字段中，如果字段类型是datetime，插入数据是不受任何时区影响的(包括服务本地时区、MySQL运行服务器时区及MySQL自己时区)，这就是Date代表的时间至少时间戳的封装，相当于一个long型，时间戳是没有时区概念的。 123456789查看数据库时区：show variables like "%time_zone%";+------------------+--------+| Variable_name | Value |+------------------+--------+| system_time_zone | CST || time_zone | SYSTEM |+------------------+--------+2 rows in set (0.00 sec) time_zone说明mysql使用system的时区，system_time_zone说明system使用CST时区，CST时区在这里就代表的是北京东八区时区、 但是这里要注意下：你使用select查询的时候，其实是存在数据库中Date类型到字符串转换的过程，因为你使用select查询看到的时间一般都是“2017-10-1 12:00:00”等这种格式，这就是数据库时区的作用，同理，如果数据库字段是datetime，你insert时指定的是“2017-10-1 12:00:00”等这种数据，数据库也是会存在上面说的字符串转成Date要涉及到时区，这里使用的也是数据库时区，其实更上面介绍的Date传递原理是一致的。如果你把数据库时区修改了，select查询出来同样的数据，展示的时间字符串是不一样的，就是这个道理。 5、服务B从数据库查询，查询出来的是一个Date类型，这里是不会涉及到任何时区问题。可能经常会出现下面一种情况： 12341、客户端1从数据库查询该数据看到的是2018-01-03 16:02:04.591，因为没有指定时区默认使用的是本地时区，假设为东八区2、客户端2从数据库查询拿到同样的数据，但是输出的确是2018-01-03 08:02:04.591，因为客户端本地系统时区为UTF时区3、虽然客户端1和客户端2看到像是不同的时间，但是它们拿到的是同一份数据，指向的时间也是同一个时刻的时间，即这一个时间时刻在不同时区有不同的表示，但是代表的时间都是同一个时刻4、如果需要统一时区，需要向之前样式，转换时指定时区即可 ​ 总结计算机中的时间都是通过时间戳表示的，如程序中的Date类型、数据库中的Date类型，其内部就是对时间戳的一个封装，时间戳没有时区概念，所以在计算机中的时间是没有时区概念的。 那么为什么会有时区概念呢？时区存在主要是为了：自然时间表示时必须要有时区才有意义，否则时间是没有意义的。自然时间就是现实生活中人们所认识的时间，计算机中的时间是时间戳，在现实生活中肯定是不方便理解的，现实生活中我们还是更倾向使用”2018-01-20 18:00:00”这种自然时间，但是这个时间表示是有问题的：到底是哪个时区的1月20号18点呢？ 时间的概念更倾向于时刻，它是全世界唯一的，比如现在这个时刻东八区北京时间是：2018-1-25 15:30:30，其对应的时间戳是1516865430404，但是同样这刻在零时区时间是：2018-1-25 07:30:30，但是它的时间戳依然是1516865430404，也就是说，计算机中的时间戳是一个时刻的概念，不存在时区区别，但是当这个时刻表示为自然时间时就存在不同时区表示方法不一样了。 综上来看，我们在程序开发中，当存在”2018-01-20 18:00:00”解析为Date类型，或Date类型格式化为”2018-01-20 18:00:00”，即计算机时间和自然时间相互转换时，就一定要注意时区，这是因为当出现”2018-01-20 18:00:00”必须带有时区才有意义。 在平时开发中，如果多系统间需要传递时间，最近实践是采用时间戳传递而不是”2018-01-20 18:00:00”这种时间格式传递，原因如下：​ 1、时间戳占用的字节大小比2018-01-03 16:02:04.591小很多，在系统间传递网络带宽更有优势；​ 2、当然最主要的还是：时间戳不存在时区概念，不需要进行转换，而2018-01-03 16:02:04.591格式在传递时进行转换非常容易引起混乱导致错误​ 3、数据库中的时间类型采用long型时间戳，效率更高]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
